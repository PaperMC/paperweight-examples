From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: derverdox <mail.ysp@web.de>
Date: Tue, 20 Feb 2024 21:06:48 +0100
Subject: [PATCH] Adding Behaviours


diff --git a/src/main/java/de/verdox/itemformat/BasicItemFormat.java b/src/main/java/de/verdox/itemformat/BasicItemFormat.java
new file mode 100644
index 0000000000000000000000000000000000000000..9eff8786195ff9543397f5261c2a0091e40646c9
--- /dev/null
+++ b/src/main/java/de/verdox/itemformat/BasicItemFormat.java
@@ -0,0 +1,53 @@
+package de.verdox.itemformat;
+
+import de.verdox.mccreativelab.CustomBehaviour;
+import org.bukkit.NamespacedKey;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.persistence.PersistentDataType;
+import org.jetbrains.annotations.NotNull;
+import java.util.Objects;
+import java.util.concurrent.ThreadLocalRandom;
+
+@FunctionalInterface
+public interface BasicItemFormat {
+    CustomBehaviour<BasicItemFormat> BASIC_FORMAT = new CustomBehaviour<>(BasicItemFormat.class, stack -> {}, "BasicItemFormat");
+    void applyItemFormat(ItemStack stack);
+    static ItemStack applyItemFormatAndReturn(ItemStack stack){
+        return applyItemFormatAndReturn(stack, BASIC_FORMAT.getBehaviour());
+    }
+
+    static ItemStack applyItemFormatAndReturn(@NotNull ItemStack stack, @NotNull BasicItemFormat basicItemFormat) {
+        Objects.requireNonNull(stack);
+        Objects.requireNonNull(basicItemFormat);
+        if(needsConversion(stack)){
+            basicItemFormat.applyItemFormat(stack);
+            applyConversionTag(stack);
+        }
+        return stack;
+    }
+
+    static ItemStack forceItemFormat(@NotNull ItemStack stack, @NotNull BasicItemFormat basicItemFormat){
+        Objects.requireNonNull(stack);
+        Objects.requireNonNull(basicItemFormat);
+        basicItemFormat.applyItemFormat(stack);
+        return stack;
+    }
+
+    String randomSessionID = Integer.toHexString(ThreadLocalRandom.current().nextInt(1000000));
+    NamespacedKey sessionIDKey = new NamespacedKey("mcclab","session_id");
+    static boolean needsConversion(ItemStack stack){
+        if(org.bukkit.Bukkit.getServer() == null) // When Bukkit has not loaded yet do not use BasicItemFormat
+            return false;
+        if(stack == null || stack.isEmpty())
+            return false;
+        if(!stack.hasItemMeta())
+            return true;
+        if(!stack.getItemMeta().getPersistentDataContainer().has(sessionIDKey))
+            return true;
+        var storedID = stack.getItemMeta().getPersistentDataContainer().get(sessionIDKey, PersistentDataType.STRING);
+        return !randomSessionID.equals(storedID);
+    }
+    static void applyConversionTag(ItemStack stack){
+        stack.editMeta(meta -> meta.getPersistentDataContainer().set(sessionIDKey, PersistentDataType.STRING, randomSessionID));
+    }
+}
diff --git a/src/main/java/de/verdox/mccreativelab/CustomBehaviour.java b/src/main/java/de/verdox/mccreativelab/CustomBehaviour.java
new file mode 100644
index 0000000000000000000000000000000000000000..1fb3445619006e1911c25f68489a9675ca704f78
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/CustomBehaviour.java
@@ -0,0 +1,48 @@
+package de.verdox.mccreativelab;
+
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Objects;
+
+/**
+ * Used as wrapper class for custom implemented behaviour.
+ * This is normally used to change constants in the minecraft gameplay.
+ * @param <T>
+ */
+public class CustomBehaviour<T> {
+    private final ProxyInterface<T> proxyInterface;
+    private final String key;
+    public CustomBehaviour(Class<? extends T> type, T defaultImplementation, String key){
+        this.key = key;
+        this.proxyInterface = new ProxyInterface<>(type, defaultImplementation);
+    }
+
+    public String getKey() {
+        return key;
+    }
+
+    /**
+     * Used to set a new behaviour.
+     * @param behaviour The new implementation
+     */
+    public void setBehaviour(@NotNull T behaviour) {
+        Objects.requireNonNull(behaviour);
+        this.proxyInterface.addImplementation(behaviour);
+    }
+
+    @ApiStatus.Internal
+    public T getBehaviour() {
+        return proxyInterface.getImplementation();
+    }
+
+    /**
+     * Checks if a custom implementation exists
+     * @return true if a custom implementation exists
+     */
+    public boolean isImplemented(){
+        return proxyInterface.isImplemented();
+    }
+}
diff --git a/src/main/java/de/verdox/mccreativelab/ItemInteractionResult.java b/src/main/java/de/verdox/mccreativelab/ItemInteractionResult.java
new file mode 100644
index 0000000000000000000000000000000000000000..e08871feb78378853e3755950e7e4dbe10786a23
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/ItemInteractionResult.java
@@ -0,0 +1,28 @@
+package de.verdox.mccreativelab;
+
+public enum ItemInteractionResult {
+    SUCCESS,
+    CONSUME,
+    CONSUME_PARTIAL,
+    PASS_TO_DEFAULT_BLOCK_INTERACTION,
+    SKIP_DEFAULT_BLOCK_INTERACTION,
+    FAIL;
+
+    public boolean consumesAction() {
+        return this.result().consumesAction();
+    }
+
+    public static ItemInteractionResult sidedSuccess(boolean swingHand) {
+        return swingHand ? SUCCESS : CONSUME;
+    }
+
+    public InteractionResult result() {
+        return switch (this) {
+            case SUCCESS -> InteractionResult.SUCCESS;
+            case CONSUME -> InteractionResult.CONSUME;
+            case CONSUME_PARTIAL -> InteractionResult.CONSUME_PARTIAL;
+            case PASS_TO_DEFAULT_BLOCK_INTERACTION, SKIP_DEFAULT_BLOCK_INTERACTION -> InteractionResult.PASS;
+            case FAIL -> InteractionResult.FAIL;
+        };
+    }
+}
diff --git a/src/main/java/de/verdox/mccreativelab/InteractionResult.java b/src/main/java/de/verdox/mccreativelab/InteractionResult.java
new file mode 100644
index 0000000000000000000000000000000000000000..c2a38adb30a24ca03ce2a65d14a06c3e1b5d9711
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/InteractionResult.java
@@ -0,0 +1,26 @@
+package de.verdox.mccreativelab;
+
+public enum InteractionResult {
+    SUCCESS,
+    SUCCESS_NO_ITEM_USED,
+    CONSUME,
+    CONSUME_PARTIAL,
+    PASS,
+    FAIL;
+
+    public boolean consumesAction() {
+        return this == SUCCESS || this == CONSUME || this == CONSUME_PARTIAL || this == SUCCESS_NO_ITEM_USED;
+    }
+
+    public boolean shouldSwing() {
+        return this == SUCCESS || this == SUCCESS_NO_ITEM_USED;
+    }
+
+    public boolean indicateItemUse() {
+        return this == SUCCESS || this == CONSUME;
+    }
+
+    public static InteractionResult sidedSuccess(boolean swingHand) {
+        return swingHand ? SUCCESS : CONSUME;
+    }
+}
diff --git a/src/main/java/de/verdox/mccreativelab/MultiCustomBehaviour.java b/src/main/java/de/verdox/mccreativelab/MultiCustomBehaviour.java
new file mode 100644
index 0000000000000000000000000000000000000000..0968745752d45ef649b7322ea51749068a3f65d9
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/MultiCustomBehaviour.java
@@ -0,0 +1,53 @@
+package de.verdox.mccreativelab;
+
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Objects;
+
+public class MultiCustomBehaviour<K, T> {
+    private final String key;
+    private final Class<? extends T> type;
+    private final T defaultImplementation;
+    public final Map<K, ProxyInterface<T>> storedBehaviour = new HashMap<>();
+
+    public MultiCustomBehaviour(Class<T> type, T defaultImplementation, String key) {
+        this.key = key;
+        this.type = type;
+        this.defaultImplementation = defaultImplementation;
+    }
+
+    public String getKey() {
+        return key;
+    }
+
+    /**
+     * Used to set a new behaviour.
+     *
+     * @param behaviour The new implementation
+     */
+    public void setBehaviour(@NotNull K key, @NotNull T behaviour) {
+        Objects.requireNonNull(key);
+        Objects.requireNonNull(behaviour);
+        storedBehaviour.computeIfAbsent(key, k -> new ProxyInterface<>(type, defaultImplementation)).addImplementation(behaviour);
+    }
+
+    @Nullable
+    @ApiStatus.Internal
+    public T getBehaviour(@NotNull K key) {
+        Objects.requireNonNull(key);
+        return storedBehaviour.computeIfAbsent(key, k -> new ProxyInterface<>(type, defaultImplementation)).getImplementation();
+    }
+
+    /**
+     * Checks if a custom implementation exists
+     * @return true if a custom implementation exists
+     */
+    public boolean isImplemented(@NotNull K key){
+        Objects.requireNonNull(key);
+        return storedBehaviour.containsKey(key);
+    }
+}
diff --git a/src/main/java/de/verdox/mccreativelab/ProxyInterface.java b/src/main/java/de/verdox/mccreativelab/ProxyInterface.java
new file mode 100644
index 0000000000000000000000000000000000000000..db4b4eb18027182d999565d0b19e9514440f6f60
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/ProxyInterface.java
@@ -0,0 +1,125 @@
+package de.verdox.mccreativelab;
+
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.lang.reflect.Proxy;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.function.BiFunction;
+
+/**
+ * A proxy interface provider that merges various implementations of the same interface to one proxy instance.
+ *
+ * @param <T>
+ */
+public class ProxyInterface<T> {
+    private final Map<Method, T> methodToImplementationCache = new HashMap<>();
+    private final Class<? extends T> type;
+    private final T defaultImplementation;
+    private final T proxy;
+
+    public ProxyInterface(Class<? extends T> type, T defaultImplementation) {
+        this.type = type;
+        this.defaultImplementation = defaultImplementation;
+        this.proxy = createProxy();
+    }
+
+    public T getImplementation() {
+        return this.proxy;
+    }
+
+    public void addImplementation(T implementation, BiFunction<T, Method, Boolean> replaceExistingMethodImplementation) {
+        for (Method declaredMethod : implementation.getClass().getMethods()) {
+            if(!Modifier.isPublic(declaredMethod.getModifiers()))
+                continue;
+            MethodOriginFinder methodOriginFinder = new MethodOriginFinder();
+            methodOriginFinder.startFindingMethod(declaredMethod);
+            Method overridenMethod = methodOriginFinder.getOriginalMethod();
+            if (overridenMethod == null)
+                continue;
+            if (methodToImplementationCache.containsKey(overridenMethod) && (replaceExistingMethodImplementation == null || !replaceExistingMethodImplementation.apply(methodToImplementationCache.get(overridenMethod), overridenMethod)))
+                continue;
+            methodToImplementationCache.put(overridenMethod, implementation);
+        }
+    }
+
+    public boolean isImplemented() {
+        return !methodToImplementationCache.isEmpty();
+    }
+
+    public void addImplementation(T implementation) {
+        addImplementation(implementation, null);
+    }
+
+    private T createProxy() {
+        return type.cast(Proxy.newProxyInstance(
+            type.getClassLoader(),
+            new Class<?>[]{type},
+            (proxy, method, args) -> {
+
+                T implementation = defaultImplementation;
+
+                if (methodToImplementationCache.containsKey(method)) {
+                    implementation = methodToImplementationCache.get(method);
+                }
+
+                return method.invoke(implementation, args);
+            }
+        ));
+    }
+
+    public static class MethodOriginFinder {
+        private Class<?> result;
+        private Method foundMethod;
+
+        public void startFindingMethod(Method method) {
+            startFindingMethod(method.getDeclaringClass(), method.getName(), method.getParameterTypes());
+        }
+
+        public synchronized void startFindingMethod(Class<?> currentClass, String methodName, Class<?>... parameterTypes) {
+            result = null;
+            foundMethod = null;
+            search(currentClass, methodName, parameterTypes);
+        }
+
+        public Class<?> getClassDeclaringMethod() {
+            return result;
+        }
+
+        public Method getOriginalMethod() {
+            return foundMethod;
+        }
+
+        private boolean search(Class<?> currentClass, String methodName, Class<?>... parameterTypes) {
+            if (result != null)
+                return false;
+            boolean foundInSuperClass = false;
+            if (currentClass.getSuperclass() != null && !currentClass.getSuperclass().equals(Object.class)) {
+                var found = search(currentClass.getSuperclass(), methodName, parameterTypes);
+                if (found)
+                    foundInSuperClass = true;
+            }
+
+            boolean foundInAnyInterface = false;
+            for (Class<?> anInterface : currentClass.getInterfaces()) {
+                var foundMethodInInterface = search(anInterface, methodName, parameterTypes);
+                if (foundMethodInInterface)
+                    foundInAnyInterface = true;
+            }
+
+
+            try {
+                Method method = currentClass.getMethod(methodName, parameterTypes);
+
+                if (!foundInSuperClass && !foundInAnyInterface && !currentClass.equals(Object.class)) {
+                    result = currentClass;
+                    foundMethod = method;
+                }
+
+                return true;
+            } catch (NoSuchMethodException e) {
+                return false;
+            }
+        }
+    }
+}
diff --git a/src/main/java/de/verdox/mccreativelab/behaviour/Behaviour.java b/src/main/java/de/verdox/mccreativelab/behaviour/Behaviour.java
new file mode 100644
index 0000000000000000000000000000000000000000..9dc0f3aff2672c513cb6ba3d5f6c42cc40fb33c0
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/behaviour/Behaviour.java
@@ -0,0 +1,31 @@
+package de.verdox.mccreativelab.behaviour;
+
+public interface Behaviour {
+    default BehaviourResult.Void voidResult(BehaviourResult.Void.Type type) {
+        return new BehaviourResult.Void(type);
+    }
+
+    default BehaviourResult.Void voidResult() {
+        return voidResult(BehaviourResult.Void.Type.REPLACE_VANILLA);
+    }
+
+    default BehaviourResult.Callback done() {
+        return new BehaviourResult.Callback();
+    }
+
+    default BehaviourResult.Bool bool(boolean value, BehaviourResult.Bool.Type type) {
+        return new BehaviourResult.Bool(value, type);
+    }
+
+    default BehaviourResult.Bool bool(boolean value) {
+        return bool(value, BehaviourResult.Bool.Type.REPLACE_VANILLA);
+    }
+
+    default <T> BehaviourResult.Object<T> result(T result, BehaviourResult.Object.Type type){
+        return new BehaviourResult.Object<>(result, type);
+    }
+
+    default <T> BehaviourResult.Object<T> result(T result){
+        return result(result, BehaviourResult.Object.Type.REPLACE_VANILLA);
+    }
+}
diff --git a/src/main/java/de/verdox/mccreativelab/behaviour/BehaviourResult.java b/src/main/java/de/verdox/mccreativelab/behaviour/BehaviourResult.java
new file mode 100644
index 0000000000000000000000000000000000000000..21e354fd7cc2b0f6591d228c6bbf9f60b2b1f50d
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/behaviour/BehaviourResult.java
@@ -0,0 +1,132 @@
+package de.verdox.mccreativelab.behaviour;
+
+import java.util.function.Supplier;
+
+/**
+ * @param <T> The actual return value of a behaviour that was run.
+ * @param <R> The Result Type
+ */
+public abstract class BehaviourResult<T, R extends Enum<?>> {
+    private final T value;
+    private final R result;
+
+    BehaviourResult(T value, R result) {
+        this.value = value;
+        this.result = result;
+    }
+
+    public T getValue() {
+        return value;
+    }
+
+    public R getResult() {
+        return result;
+    }
+
+    protected abstract T evaluateReturnValue(Supplier<T> vanillaLogic);
+    protected abstract boolean replaceVanillaLogic();
+
+    public static class Callback extends BehaviourResult<java.lang.Void, Callback.Type> {
+        public static final Callback DEFAULT_INSTANCE = new Callback();
+
+        Callback() {
+            super(null, Type.NONE);
+        }
+
+        @Override
+        protected java.lang.Void evaluateReturnValue(Supplier<java.lang.Void> vanillaLogic) {
+            return null;
+        }
+
+        @Override
+        protected boolean replaceVanillaLogic() {
+            return false;
+        }
+
+        public enum Type {
+            NONE,
+        }
+    }
+
+    public static class Void extends BehaviourResult<java.lang.Void, Void.Type> {
+        public static final Void DEFAULT_INSTANCE = new Void(Void.Type.USE_VANILLA);
+
+        public Void(Type result) {
+            super(null, result);
+        }
+
+        public boolean replaceVanillaLogic() {
+            return Type.REPLACE_VANILLA.equals(getResult());
+        }
+
+        @Override
+        protected java.lang.Void evaluateReturnValue(Supplier<java.lang.Void> vanillaLogic) {
+            if (!Type.REPLACE_VANILLA.equals(getResult()))
+                return vanillaLogic.get();
+            else
+                return getValue();
+        }
+
+        public enum Type {
+            REPLACE_VANILLA,
+            USE_VANILLA
+        }
+    }
+
+    public static class Bool extends BehaviourResult<Boolean, Bool.Type> {
+        public static final Bool DEFAULT_INSTANCE = new Bool(false, Type.ONLY_VANILLA);
+
+        public Bool(Boolean value, Type result) {
+            super(value, result);
+        }
+
+        @Override
+        protected Boolean evaluateReturnValue(Supplier<Boolean> vanillaLogic) {
+            return switch (getResult()) {
+                case AND -> vanillaLogic.get() && getValue();
+                case OR -> vanillaLogic.get() || getValue();
+                case XOR -> vanillaLogic.get() ^ getValue();
+                case REPLACE_VANILLA -> getValue();
+                case ONLY_VANILLA -> vanillaLogic.get();
+            };
+        }
+
+        @Override
+        protected boolean replaceVanillaLogic() {
+            return Bool.Type.REPLACE_VANILLA.equals(getResult());
+        }
+        public enum Type {
+            AND,
+            OR,
+            XOR,
+            REPLACE_VANILLA,
+            ONLY_VANILLA,
+        }
+    }
+
+    public static class Object<T> extends BehaviourResult<T, Object.Type> {
+        public static final Object DEFAULT_INSTANCE = new Object(null, Type.USE_VANILLA);
+
+        public Object(T value, Type result) {
+            super(value, result);
+        }
+
+        @Override
+        protected T evaluateReturnValue(Supplier<T> vanillaLogic) {
+            return switch (getResult()) {
+                case REPLACE_VANILLA -> getValue();
+                case USE_VANILLA -> vanillaLogic.get();
+            };
+        }
+
+        @Override
+        protected boolean replaceVanillaLogic() {
+            return Object.Type.REPLACE_VANILLA.equals(getResult());
+        }
+
+        public enum Type {
+            REPLACE_VANILLA,
+            USE_VANILLA
+        }
+    }
+}
diff --git a/src/main/java/de/verdox/mccreativelab/behaviour/BlockBehaviour.java b/src/main/java/de/verdox/mccreativelab/behaviour/BlockBehaviour.java
new file mode 100644
index 0000000000000000000000000000000000000000..62bf361289c4ccb7c70cc835cd97c723def1dc09
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/behaviour/BlockBehaviour.java
@@ -0,0 +1,249 @@
+package de.verdox.mccreativelab.behaviour;
+
+import de.verdox.mccreativelab.InteractionResult;
+import de.verdox.mccreativelab.ItemInteractionResult;
+import de.verdox.mccreativelab.MultiCustomBehaviour;
+import de.verdox.mccreativelab.random.VanillaRandomSource;
+import org.bukkit.Location;
+import org.bukkit.Material;
+import org.bukkit.World;
+import org.bukkit.block.Block;
+import org.bukkit.block.BlockFace;
+import org.bukkit.block.data.BlockData;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+import org.bukkit.inventory.EquipmentSlot;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.util.RayTraceResult;
+import org.bukkit.util.Vector;
+
+public interface BlockBehaviour extends Behaviour {
+    MultiCustomBehaviour<Material, BlockBehaviour> BLOCK_BEHAVIOUR = new MultiCustomBehaviour<>(BlockBehaviour.class, new BlockBehaviour() {}, "MCCLab - BlockBehaviour");
+
+    /**
+     * This method is called to get the explosion resistance of a block
+     *
+     * @param block     The block
+     * @param blockData The blockData of the block
+     * @return float result
+     */
+    default BehaviourResult.Object<Float> getExplosionResistance(Block block, BlockData blockData) {
+        return BehaviourResult.Object.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * This method is called everytime the block receives a block update due to any reason.
+     * Normally this happens when a block next to this block was changed. If you want to implement any custom behaviour on environmental changes use this method.
+     *
+     * @param location           The location of the block
+     * @param blockData          The blockData of the block
+     * @param direction          The direction of the Blockupdate
+     * @param neighbourBlockData The neighbour blockdata that issued the block update
+     * @param neighbourLocation  The neighbour location
+     * @return The blockdata that results from this update.
+     */
+    default BehaviourResult.Object<BlockData> blockUpdate(Location location, BlockData blockData, BlockFace direction, BlockData neighbourBlockData, Location neighbourLocation) {
+        return result(blockData, BehaviourResult.Object.Type.USE_VANILLA);
+    }
+
+    /**
+     * This method is called everytime the block recognizes a neighbour block update
+     * Normally this happens when a block next to this block was changed. If you want to implement any custom behaviour on environmental changes use this method.
+     *
+     * @param block           The block recognizing the neighbour update
+     * @param sourceBlock     The neighbour block receiving the block update
+     * @param notify          The Notify flag
+     */
+    default BehaviourResult.Void onNeighbourBlockUpdate(Block block, Block sourceBlock, boolean notify) {
+        return BehaviourResult.Void.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * This method is called whenever an entity steps on a block
+     *
+     * @param block     The block
+     * @param blockData The blockData of the block
+     * @param entity    The Entity stepping on the block
+     * @return void result
+     */
+    default BehaviourResult.Void stepOn(Block block, BlockData blockData, Entity entity) {
+        return BehaviourResult.Void.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * This method is called every time the server software tries to randomly tick a block.
+     *
+     * @param block               The randomly ticked block
+     * @param vanillaRandomSource The vanilla random source
+     */
+    default BehaviourResult.Void randomTick(Block block, VanillaRandomSource vanillaRandomSource) {
+        return BehaviourResult.Void.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * This method is called to check if a blockdata is randomly ticking regardless of it being placed in a world right now.
+     *
+     * @param blockData The block data of the block
+     * @return A boolean result
+     */
+    default BehaviourResult.Bool isBlockDataRandomlyTicking(BlockData blockData) {
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * This method is called to check if a block in a world is randomly ticking
+     *
+     * @param block     The block
+     * @param blockData The block data of the block
+     * @return A boolean result
+     */
+    default BehaviourResult.Bool isBlockRandomlyTicking(Block block, BlockData blockData) {
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * This callback is run after the server placed a block due to any reason. This method is NOT called when a player places block!
+     *
+     * @param location     The location
+     * @param newBlockData The new block data
+     * @param oldBlockData The old block data
+     * @param notify       Whether this notifies the world
+     * @return callback
+     */
+    default BehaviourResult.Callback onPlace(Location location, BlockData newBlockData, BlockData oldBlockData, boolean notify, boolean isProcessingBlockPlaceEvent) {
+        return BehaviourResult.Callback.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * This callback is run after a player successfully placed a block. If the Block Place Action was cancelled by an event this function is not called.
+     *
+     * @param player   The player
+     * @param location The location
+     * @return callback
+     */
+    default BehaviourResult.Callback onPlayerPlace(Player player, ItemStack stackUsedToPlaceBlock, Location location, BlockData thePlacedState) {
+        return BehaviourResult.Callback.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * This callback is run after a player breaks a block
+     *
+     * @param player      The player
+     * @param location    The location
+     * @param brokenState The broken block state
+     * @return callback
+     */
+    default BehaviourResult.Callback onPlayerBreak(Player player, Location location, BlockData brokenState) {
+        return BehaviourResult.Callback.DEFAULT_INSTANCE;
+    }
+
+
+    /**
+     * This callback is run after the server removes a block due to any reason. This does not include a player breaking a block.
+     *
+     * @param location     The location
+     * @param newBlockData The new block data
+     * @param oldBlockData The old block data
+     * @param moved        Whether the block was moved
+     * @return callback
+     */
+    default BehaviourResult.Callback onRemove(Location location, BlockData newBlockData, BlockData oldBlockData, boolean moved) {
+        return BehaviourResult.Callback.DEFAULT_INSTANCE;
+    }
+
+    /**
+     *
+     * @param location - The block location
+     * @param drop - True if the block dropped items
+     * @param destroyingEntity - The Entity that destroyed the block
+     * @param maxUpdateDepth - The chunk update depth
+     * @return a callback object
+     */
+    default BehaviourResult.Callback onDestroy(Location location, boolean drop, @javax.annotation.Nullable Entity destroyingEntity, int maxUpdateDepth) {
+        return BehaviourResult.Callback.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * This method is run when a player interacts with a block in any way. By overriding this method, various bukkit events, paper code, and fixed won't be called.
+     *
+     * @param block          The block
+     * @param player         The player
+     * @param hand           The Hand used to interact
+     * @param rayTraceResult The interaction info
+     * @return The result of this interaction
+     */
+    default BehaviourResult.Object<ItemInteractionResult> use(Block block, Player player, EquipmentSlot hand, RayTraceResult rayTraceResult) {
+        return BehaviourResult.Object.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * This callback is run after a player interacted with this block. This method is not run on blocks that call bukkit events! Only on those that do not define any specific onUse Behaviour
+     *
+     * @param block          The block
+     * @param player         The player
+     * @param hand           The Hand used to interact
+     * @param rayTraceResult The interaction info
+     * @return callback
+     */
+    default BehaviourResult.Callback onUseCallback(Block block, Player player, EquipmentSlot hand, RayTraceResult rayTraceResult, InteractionResult interactionResult) {
+        return BehaviourResult.Callback.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * This callback is run after a block was successfully moved by a piston
+     *
+     * @return callback
+     */
+    default BehaviourResult.Callback onPistonMoveBlock(BlockData blockDataMoved, Location positionBeforeMove, Location positionAfterMove, Block piston, Vector moveDirection) {
+        return BehaviourResult.Callback.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * This method is called every time the server software ticks a block.
+     * <p>
+     * Some blocks may not be ticked in vanilla by default. For example Stone blocks don't receive ticks.
+     * Please use the blockUpdate method to implement any custom logic or to call this method.
+     *
+     * @param block               The ticked block
+     * @param vanillaRandomSource The vanilla random source
+     */
+    default BehaviourResult.Void tick(Block block, VanillaRandomSource vanillaRandomSource) {
+        return BehaviourResult.Void.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * This method is called to check if a block can survive in the current environment
+     * <p>
+     * Some blocks may not use this method by default.
+     * Please use the blockUpdate method to implement any custom logic or to call this method.
+     *
+     * @param block The block
+     * @param world The world
+     * @return A boolean result
+     */
+    default BehaviourResult.Bool canSurvive(Block block, World world) {
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * This method is called every time a user left-clicks a block.
+     * <p>
+     *
+     * @param block  The clicked block
+     * @param player The player
+     */
+    default BehaviourResult.Void attack(Block block, Player player) {
+        return BehaviourResult.Void.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Called when a player uses bonemeal on a block.
+     * @param block The block that is fertilized
+     * @param stack The item used to fertilize. The Minecraft server will call this only for bonemeal.
+     * @return True if the action was a success
+     */
+    default BehaviourResult.Bool fertilizeAction(Block block, ItemStack stack){
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+}
+
diff --git a/src/main/java/de/verdox/mccreativelab/behaviour/FoodBehaviour.java b/src/main/java/de/verdox/mccreativelab/behaviour/FoodBehaviour.java
new file mode 100644
index 0000000000000000000000000000000000000000..725480cb19dd2b2ca2b8b0569705bcc96024248c
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/behaviour/FoodBehaviour.java
@@ -0,0 +1,63 @@
+package de.verdox.mccreativelab.behaviour;
+
+import de.verdox.mccreativelab.CustomBehaviour;
+import org.bukkit.entity.Player;
+
+public interface FoodBehaviour extends Behaviour {
+    /**
+     * If you wish to change the amount of health gained, use the {@link org.bukkit.event.entity.EntityRegainHealthEvent}
+     * If you wish to change the amount of damage taken by starvation, use the {@link org.bukkit.event.entity.EntityDamageEvent}
+     * This interface is solely used to manipulate the vanilla variables that are not yet changeable by the API.
+     * Implement your own version of the FoodBehaviour Interface and make FOOD_BEHAVIOUR use your implementation.
+     */
+    CustomBehaviour<FoodBehaviour> FOOD_BEHAVIOUR = new CustomBehaviour<>(FoodBehaviour.class, new FoodBehaviour() {},"MCCLab - FoodBehaviour");
+    /**
+     * Gets the regeneration rate per tick when a player is saturated.
+     * Defaults to 10 in vanilla.
+     * @param player The player
+     * @return the regeneration rate per tick
+     */
+    default int getSaturatedRegenRate(Player player){return 10;}
+    /**
+     * Gets the regeneration rate per tick when a player is unsaturated.
+     * Defaults to 80 in vanilla.
+     * @param player The player
+     * @return the regeneration rate per tick
+     */
+    default int getUnsaturatedRegenRate(Player player){return 80;}
+    /**
+     * Gets the starvation rate per tick when a player is starving.
+     * Defaults to 80 in vanilla.
+     * @param player The player
+     * @return the regeneration rate per tick
+     */
+    default int getStarvationRate(Player player){return 80;}
+    /**
+     * Gets the food level when a player starts starving
+     * Defaults to 0 in vanilla.
+     * @param player The player
+     * @return the starvation food limit
+     */
+    default int getStarvationFoodLimit(Player player){return 0;}
+    /**
+     * Gets the food level a player needs at minimum to start regenerating health
+     * Defaults to 18 in vanilla.
+     * @param player The player
+     * @return the food level
+     */
+    default int getMinimumFoodToRegenerate(Player player){return 18;}
+    /**
+     * Gets the exhaustion over time rate in ticks
+     * This is a custom feature. If the method returns an integer less or equal then -1 the feature won't be used.
+     * @param player The player
+     * @return the food level
+     */
+    default int getExhaustionOverTimeRateInTicks(Player player){return 0;}
+    /**
+     * Gets the exhaustion amount over time
+     * * This is a custom feature. If the method returns an integer less or equal then 0 the feature won't be used.
+     * @param player The player
+     * @return the food level
+     */
+    default int getExhaustionOverTimeAmount(Player player){return 0;}
+}
diff --git a/src/main/java/de/verdox/mccreativelab/behaviour/ItemBehaviour.java b/src/main/java/de/verdox/mccreativelab/behaviour/ItemBehaviour.java
new file mode 100644
index 0000000000000000000000000000000000000000..3c1510a9d56484e9792b6de7283e34d3cfe5925e
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/behaviour/ItemBehaviour.java
@@ -0,0 +1,204 @@
+package de.verdox.mccreativelab.behaviour;
+
+import de.verdox.mccreativelab.InteractionResult;
+import de.verdox.mccreativelab.MultiCustomBehaviour;
+import de.verdox.mccreativelab.behaviour.interaction.ItemStackInteraction;
+import de.verdox.mccreativelab.recipe.CustomItemData;
+import org.bukkit.Location;
+import org.bukkit.block.Block;
+import org.bukkit.block.data.BlockData;
+import org.bukkit.entity.Item;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.entity.Player;
+import org.bukkit.inventory.EquipmentSlot;
+import org.bukkit.inventory.FoodProperties;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.util.RayTraceResult;
+
+public interface ItemBehaviour extends Behaviour {
+    MultiCustomBehaviour<CustomItemData, ItemBehaviour> ITEM_BEHAVIOUR = new MultiCustomBehaviour<>(ItemBehaviour.class, new ItemBehaviour() {
+    }, "MCCLab - ItemBehaviour");
+
+    /**
+     * Called after an {@link ItemStack} was used by a {@link LivingEntity}
+     * @param livingEntity - The LivingEntity
+     * @param usedItem - The ItemStack
+     * @return - The ItemStack that is left after using it
+     */
+    default BehaviourResult.Object<ItemStack> finishUsingItem(LivingEntity livingEntity, ItemStack usedItem) {
+        return BehaviourResult.Object.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Gets the max stack size of an {@link ItemStack}
+     * @param stack - The ItemStack
+     * @return - The max stack size.
+     */
+    default BehaviourResult.Object<Integer> getMaxStackSize(ItemStack stack) {
+        return BehaviourResult.Object.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Gets the max durability of an {@link ItemStack}
+     * @param stack - The ItemStack
+     * @return - The max durability
+     */
+    default BehaviourResult.Object<Integer> getMaxDamage(ItemStack stack) {
+        return BehaviourResult.Object.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Called when an {@link ItemStack} is used to mine a {@link Block} by a {@link Player}
+     * @param stack - The ItemStack
+     * @param block - The block
+     * @param miner - The miner
+     * @return - If the block was mined successfully
+     */
+    default BehaviourResult.Bool mineBlock(ItemStack stack, Block block, Player miner) {
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Is called to determine if an {@link ItemStack} is the correct tool to drop loot from {@link BlockData}
+     * @param stack - The item stack
+     * @param blockData - The block data
+     * @return - True when it is the correct tool
+     */
+    default BehaviourResult.Bool isCorrectToolForDrops(ItemStack stack, BlockData blockData) {
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Called when an amount of {@link ItemStack} is crafted by a {@link Player}
+     * @param stack - The ItemStack
+     * @param player - The crafter
+     * @param amount - The amount crafted
+     * @return - Nothing
+     */
+    default BehaviourResult.Void onCraftedBy(ItemStack stack, Player player, int amount) {
+        return BehaviourResult.Void.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Called when an {@link Item} is destroyed in the world
+     * @param stack - The ItemStack of the item
+     * @param item - The Item entity
+     * @return - nothing
+     */
+    default BehaviourResult.Void onDestroyed(ItemStack stack, Item item) {
+        return BehaviourResult.Void.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Is called to check if an {@link ItemStack} is edible.
+     *
+     * This might result in strange client side behaviour since the value is not synced with the client.
+     * @param stack - The ItemStack
+     * @return - True if it is edible
+     */
+    default BehaviourResult.Bool isEdible(ItemStack stack) {
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Gets if the {@link ItemStack} fits inside container items like Shulker Boxes or Bundles
+     * @param stack - The ItemStack
+     * @return - true if it fits
+     */
+    default BehaviourResult.Bool canBreakWhenMaxDamage(ItemStack stack) {
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Gets if the {@link ItemStack} can drop from an inventory on death
+     * @param stack - The ItemStack
+     * @return - true if it can drop
+     */
+    default BehaviourResult.Bool canDropOnDeath(ItemStack stack) {
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Called when a {@link Player} interacts with a {@link LivingEntity} with an {@link ItemStack}
+     * @param stack - The ItemStack
+     * @param player - The Player
+     * @param livingEntity - The LivingEntity
+     * @param equipmentSlot - The hand in which the item is carried
+     * @return - An InteractionResult
+     */
+    default BehaviourResult.Object<InteractionResult> interactLivingEntity(ItemStack stack, Player player, LivingEntity livingEntity, EquipmentSlot equipmentSlot) {
+        return BehaviourResult.Object.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Called when a {@link Player} uses an {@link ItemStack}
+     * @param stack - The ItemStack
+     * @param player - The Player
+     * @param equipmentSlot - The hand in which the item is carried
+     * @return - An InteractionResult
+     */
+    default BehaviourResult.Object<ItemStackInteraction> use(ItemStack stack, Player player, EquipmentSlot equipmentSlot) {
+        return BehaviourResult.Object.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Called when a {@link Player} uses an {@link ItemStack} on a {@link Block}
+     * @param stack - The ItemStack
+     * @param player - The Player
+     * @param rayTraceResult - The hit block information
+     * @param equipmentSlot - The hand in which the item is carried
+     * @return - An InteractionResult
+     */
+    default BehaviourResult.Object<InteractionResult> useOn(ItemStack stack, Player player, EquipmentSlot equipmentSlot, RayTraceResult rayTraceResult) {
+        return BehaviourResult.Object.DEFAULT_INSTANCE;
+    }
+
+    /**
+     *Gets the {@link FoodProperties} of an {@link ItemStack}
+     * @param stack - The ItemStack
+     * @return - The FoodProperties
+     */
+    default BehaviourResult.Object<FoodProperties> getFoodProperties(ItemStack stack) {
+        return BehaviourResult.Object.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Gets the {@link ItemStack} that remains when {@link ItemStack} are crafted.
+     * @param stack - The ItemStack that was crafted
+     * @return - The ItemStack that remains in the crafting matrix
+     */
+    default BehaviourResult.Object<ItemStack> getCraftRemainingItem(ItemStack stack) {
+        return BehaviourResult.Object.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Gets if the {@link ItemStack} is fire-resistant
+     * @param stack - The ItemStack
+     * @return - true if it is fire-resistant
+     */
+    default BehaviourResult.Bool isFireResistant(ItemStack stack) {
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Gets if the {@link ItemStack} fits inside container items like Shulker Boxes or Bundles
+     * @param stack - The ItemStack
+     * @return - true if it fits
+     */
+    default BehaviourResult.Bool canFitInsideContainerItems(ItemStack stack) {
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Gets if the {@link ItemStack} is enchantable
+     * @param stack - The ItemStack
+     * @return - true if it is enchantable
+     */
+    default BehaviourResult.Bool isEnchantable(ItemStack stack) {
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Called when the {@link ItemStack} nbt is loaded
+     * @param stack - The ItemStack
+     * @return - nothing
+     */
+    default BehaviourResult.Callback onNbtLoad(ItemStack stack) {
+        return BehaviourResult.Callback.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Called when the {@link ItemStack} nbt is saved
+     * @param stack - The ItemStack
+     * @return - nothing
+     */
+    default BehaviourResult.Callback onNbtSave(ItemStack stack) {
+        return BehaviourResult.Callback.DEFAULT_INSTANCE;
+    }
+
+    default BehaviourResult.Object<BlockData> placeBlockAction(ItemStack stack, Player player, Location clickedPosition, BlockData vanillaBlockData){
+        return BehaviourResult.Object.DEFAULT_INSTANCE;
+    }
+}
diff --git a/src/main/java/de/verdox/mccreativelab/behaviour/WorldGenerationBehaviour.java b/src/main/java/de/verdox/mccreativelab/behaviour/WorldGenerationBehaviour.java
new file mode 100644
index 0000000000000000000000000000000000000000..9f2d9397a1a428220e08184571f25bbde1465c2a
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/behaviour/WorldGenerationBehaviour.java
@@ -0,0 +1,26 @@
+package de.verdox.mccreativelab.behaviour;
+
+import de.verdox.mccreativelab.CustomBehaviour;
+import de.verdox.mccreativelab.worldgen.WorldGenChunk;
+import org.bukkit.NamespacedKey;
+import org.bukkit.block.data.BlockData;
+import org.bukkit.util.BlockVector;
+
+public interface WorldGenerationBehaviour extends Behaviour {
+    CustomBehaviour<WorldGenerationBehaviour> WORLD_GENERATION_BEHAVIOUR = new CustomBehaviour<>(WorldGenerationBehaviour.class, new WorldGenerationBehaviour() {}, "MCCLab - WorldGenerationBehaviour");
+
+    /**
+     * This callback method is called everytime a block is placed due to chunk generation.
+     * Consequently, this method will be called asynchronously or synchronously depending on the thread that generates it.
+     * We suggest to implement this method with caution!
+     * @param featureType The flag indicating the feature that was generated e.g. OreFeature, TreeFeature
+     * @param blockPosition The position of the block
+     * @param worldGenChunk The WorldGenChunk of the block
+     * @param generatedBlockData The BlockData that was generated
+     */
+    default void featureBlockGenerationCallback(FeatureType featureType, BlockVector blockPosition, WorldGenChunk worldGenChunk, BlockData generatedBlockData){}
+    record FeatureType(NamespacedKey namespacedKey){
+        public static final FeatureType TREE_FEATURE = new FeatureType(NamespacedKey.minecraft("tree_feature"));
+        public static final FeatureType ORE_FEATURE = new FeatureType(NamespacedKey.minecraft("ore_feature"));
+    }
+}
diff --git a/src/main/java/de/verdox/mccreativelab/behaviour/entity/AgeableEntityBehaviour.java b/src/main/java/de/verdox/mccreativelab/behaviour/entity/AgeableEntityBehaviour.java
new file mode 100644
index 0000000000000000000000000000000000000000..c1fe314b1753cf3210a5d252fcc64da77d563a2e
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/behaviour/entity/AgeableEntityBehaviour.java
@@ -0,0 +1,7 @@
+package de.verdox.mccreativelab.behaviour.entity;
+
+import de.verdox.mccreativelab.behaviour.BehaviourResult;
+import org.bukkit.entity.Ageable;
+
+public interface AgeableEntityBehaviour<T extends Ageable> extends MobBehaviour<T> {
+}
diff --git a/src/main/java/de/verdox/mccreativelab/behaviour/entity/AnimalEntityBehaviour.java b/src/main/java/de/verdox/mccreativelab/behaviour/entity/AnimalEntityBehaviour.java
new file mode 100644
index 0000000000000000000000000000000000000000..f86f6b5102aec88ffff986f4000ef0d8e77c2a34
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/behaviour/entity/AnimalEntityBehaviour.java
@@ -0,0 +1,41 @@
+package de.verdox.mccreativelab.behaviour.entity;
+
+import de.verdox.mccreativelab.behaviour.BehaviourResult;
+import org.bukkit.entity.Ageable;
+import org.bukkit.entity.Animals;
+import org.bukkit.entity.Mob;
+import org.bukkit.inventory.ItemStack;
+
+public interface AnimalEntityBehaviour<T extends Animals> extends AgeableEntityBehaviour<T> {
+
+    /**
+     * Gets if an {@link Animals} can mate with another {@link Animals}
+     * @param entity - The first animal
+     * @param other - The other animal
+     * @return - true if it can
+     */
+    default BehaviourResult.Bool canMate(T entity, Animals other) {
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Gets if an {@link org.bukkit.entity.Entity} would eat an {@link ItemStack}
+     * @param entity - The Entity
+     * @param stack - The ItemStack
+     * @return - True if it can
+     */
+    default BehaviourResult.Bool isFood(T entity, ItemStack stack) {
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Called when an {@link Animals} breeds with another {@link Animals}
+     * @param entity - The first animal
+     * @param other - The second animal
+     * @param child - The child
+     * @return - nothing
+     */
+    default BehaviourResult.Callback onBreed(T entity, Animals other, Ageable child) {
+        return BehaviourResult.Callback.DEFAULT_INSTANCE;
+    }
+}
diff --git a/src/main/java/de/verdox/mccreativelab/behaviour/entity/EntityBehaviour.java b/src/main/java/de/verdox/mccreativelab/behaviour/entity/EntityBehaviour.java
new file mode 100644
index 0000000000000000000000000000000000000000..2203da4ffa6c1cb438502d7b8e971c0020fca697
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/behaviour/entity/EntityBehaviour.java
@@ -0,0 +1,70 @@
+package de.verdox.mccreativelab.behaviour.entity;
+
+import de.verdox.mccreativelab.behaviour.Behaviour;
+import de.verdox.mccreativelab.behaviour.BehaviourResult;
+import org.bukkit.Location;
+import org.bukkit.NamespacedKey;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+import org.bukkit.persistence.PersistentDataContainer;
+import org.bukkit.util.Vector;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.List;
+import java.util.Map;
+
+public interface EntityBehaviour<T extends Entity> extends Behaviour {
+    /**
+     * Gets if an {@link Entity} is fire immune
+     * @param entity - The entity
+     * @return - true if it is fire immune
+     */
+    default BehaviourResult.Bool fireImmune(T entity) {
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Gets if an {@link Entity} ignores a particular explosion
+     * @param entity - The entity
+     * @return - true if it ignores the explosion
+     */
+    default BehaviourResult.Bool ignoreExplosion(T entity, Location explosionLocation, float radius, @Nullable Entity source, boolean explosionHasFire, Map<Player, Vector> hitPlayers, List<Location> hitBlocks) {
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Called on every tick of an {@link Entity}
+     * @param entity - The entity
+     * @return - nothing
+     */
+    default BehaviourResult.Callback onTick(T entity){
+        return BehaviourResult.Callback.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Gets if an {@link Entity} can change dimensions
+     * @param entity - The entity
+     * @return - true if it can change dimensions
+     */
+    default BehaviourResult.Bool canChangeDimensions(T entity) {
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Is called when an {@link Entity} is loaded
+     * @param entity - The entity
+     * @return - nothing
+     */
+    default BehaviourResult.Callback readAdditionalSaveData(T entity, PersistentDataContainer persistentDataContainer){
+        return done();
+    }
+
+    /**
+     * Is called when an {@link Entity} is saved
+     * @param entity - The entity
+     * @return - nothing
+     */
+    default BehaviourResult.Callback addAdditionalSaveData(T entity, PersistentDataContainer persistentDataContainer){
+        return done();
+    }
+}
diff --git a/src/main/java/de/verdox/mccreativelab/behaviour/entity/LivingEntityBehaviour.java b/src/main/java/de/verdox/mccreativelab/behaviour/entity/LivingEntityBehaviour.java
new file mode 100644
index 0000000000000000000000000000000000000000..fd940bf18d0e45f637c0cf89a478db2bda1a0683
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/behaviour/entity/LivingEntityBehaviour.java
@@ -0,0 +1,55 @@
+package de.verdox.mccreativelab.behaviour.entity;
+
+import de.verdox.mccreativelab.behaviour.BehaviourResult;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.EntityType;
+import org.bukkit.entity.Item;
+import org.bukkit.entity.LivingEntity;
+
+public interface LivingEntityBehaviour<T extends LivingEntity> extends EntityBehaviour<T> {
+    /**
+     * Gets if an {@link LivingEntity} is sensitive to water
+     * @param entity - The entity
+     * @return - true if it is
+     */
+    default BehaviourResult.Bool isSensitiveToWater(T entity) {
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Gets the water-damage of an {@link LivingEntity} applied when it is sensitive to water
+     * @param entity - The entity
+     * @return - The water damage
+     */
+    default BehaviourResult.Object<Float> waterDamage(T entity) {
+        return BehaviourResult.Object.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Is called when an {@link LivingEntity} picks up an {@link Item}
+     * @param entity - The Entity
+     * @param item - The picked up Item
+     * @return - nothing
+     */
+    default BehaviourResult.Void onItemPickup(T entity, Item item){
+        return BehaviourResult.Void.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Gets if an {@link LivingEntity} can disable shields
+     * @param entity - The entity
+     * @return - true if it can
+     */
+    default BehaviourResult.Bool canDisableShield(T entity) {
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Gets if an {@link LivingEntity} can attack an {@link Entity} with a particular {@link EntityType}
+     * @param entity - The entity
+     * @return - true if it can
+     */
+    default BehaviourResult.Bool canAttackType(T entity, EntityType entityType) {
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+}
diff --git a/src/main/java/de/verdox/mccreativelab/behaviour/entity/MobBehaviour.java b/src/main/java/de/verdox/mccreativelab/behaviour/entity/MobBehaviour.java
new file mode 100644
index 0000000000000000000000000000000000000000..c95ab713512b39b50542fb49579d2bb054225aaf
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/behaviour/entity/MobBehaviour.java
@@ -0,0 +1,80 @@
+package de.verdox.mccreativelab.behaviour.entity;
+
+import de.verdox.mccreativelab.InteractionResult;
+import de.verdox.mccreativelab.behaviour.BehaviourResult;
+import org.bukkit.Material;
+import org.bukkit.entity.*;
+import org.bukkit.inventory.EquipmentSlot;
+import org.bukkit.inventory.ItemStack;
+
+public interface MobBehaviour <T extends Mob> extends LivingEntityBehaviour<T> {
+    /**
+     * Is called when a {@link Player} interacts with a {@link Mob}
+     * @param entity - The Entity
+     * @param player - The Player
+     * @param hand - The Interaction Hand
+     * @return - An Interaction result
+     */
+    default BehaviourResult.Object<InteractionResult> mobInteract(T entity, Player player, EquipmentSlot hand){
+        return BehaviourResult.Object.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Gets if a {@link Mob} can fire projectile weapons
+     * @param entity - The entity
+     * @param weapon - The weapon material
+     * @return - true if it can
+     */
+    default BehaviourResult.Bool canFireProjectileWeapon(T entity, Material weapon) {
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Called when an entity ate something
+     * @param entity - The Entity
+     * @return - nothing
+     */
+    default BehaviourResult.Void ate(T entity) {
+        return BehaviourResult.Void.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Gets if a {@link Mob} can hold an {@link ItemStack}
+     * @param entity - The entity
+     * @param stack - The ItemStack
+     * @return - true if it can
+     */
+    default BehaviourResult.Bool canHoldItem(T entity, ItemStack stack) {
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Gets if a {@link Mob} can pickup an {@link ItemStack}
+     * @param entity - The entity
+     * @param stack - The ItemStack
+     * @return - true if it can
+     */
+    default BehaviourResult.Bool wantsToPickUp(T entity, ItemStack stack) {
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Gets if a {@link Mob} should be removed when away a particular distance from players
+     * @param entity - The entity
+     * @param distanceSquared - The distance
+     * @return - true if it should be removed
+     */
+    default BehaviourResult.Bool removeWhenFarAway(T entity, double distanceSquared) {
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+
+    /**
+     * Gets if a {@link Mob} can be leashed by a {@link Player}
+     * @param entity - The entity
+     * @param player - The Player
+     * @return - true if it can
+     */
+    default BehaviourResult.Bool canBeLeashed(T entity, Player player) {
+        return BehaviourResult.Bool.DEFAULT_INSTANCE;
+    }
+}
diff --git a/src/main/java/de/verdox/mccreativelab/behaviour/interaction/ItemStackInteraction.java b/src/main/java/de/verdox/mccreativelab/behaviour/interaction/ItemStackInteraction.java
new file mode 100644
index 0000000000000000000000000000000000000000..dfb16c46da5cf505f3a82b08879429cd475e749f
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/behaviour/interaction/ItemStackInteraction.java
@@ -0,0 +1,7 @@
+package de.verdox.mccreativelab.behaviour.interaction;
+
+import de.verdox.mccreativelab.InteractionResult;
+import org.bukkit.inventory.ItemStack;
+
+public record ItemStackInteraction(InteractionResult interactionResult, ItemStack stack){
+}
diff --git a/src/main/java/de/verdox/mccreativelab/random/VanillaRandomSource.java b/src/main/java/de/verdox/mccreativelab/random/VanillaRandomSource.java
new file mode 100644
index 0000000000000000000000000000000000000000..0582bc507241e76964573502b880d16497ee9a0a
--- /dev/null
+++ b/src/main/java/de/verdox/mccreativelab/random/VanillaRandomSource.java
@@ -0,0 +1,27 @@
+package de.verdox.mccreativelab.random;
+
+public interface VanillaRandomSource {
+    void setSeed(long seed);
+
+    int nextInt();
+
+    int nextInt(int bound);
+
+    int nextIntBetweenInclusive(int min, int max);
+
+    long nextLong();
+
+    boolean nextBoolean();
+
+    float nextFloat();
+
+    double nextDouble();
+
+    double nextGaussian();
+
+    double triangle(double mode, double deviation);
+
+    void consumeCount(int count);
+
+    int nextInt(int min, int max);
+}
diff --git a/src/main/java/org/bukkit/entity/Entity.java b/src/main/java/org/bukkit/entity/Entity.java
index 62e3793903905b94eb1a120345015149abb33713..be92b48f06d8a15d01ee43100e5a6601087a4fe1 100644
--- a/src/main/java/org/bukkit/entity/Entity.java
+++ b/src/main/java/org/bukkit/entity/Entity.java
@@ -764,6 +764,35 @@ public interface Entity extends Metadatable, CommandSender, Nameable, Persistent
     @NotNull
     Set<String> getScoreboardTags();
 
+    // MCCreativeLab start - Add EntityBehaviour
+    /**
+     * Sets the custom behaviour for this entity
+     * @param entityTypeClass - The Entity Type class
+     * @param behaviour - The custom behaviour implementation
+     * @param <T> - The Bukkit Entity Type
+     * @param <B> - The EntityBehaviour Type
+     */
+    <T extends Entity, B extends de.verdox.mccreativelab.behaviour.entity.EntityBehaviour<T>> void setCustomEntityBehaviour(Class<? extends T> entityTypeClass, B behaviour);
+
+    /**
+     * Gets the custom behaviour for this entity
+     * @param behaviourType - The type of behaviour
+     * @param <T> - The Bukkit Entity Type
+     * @param <B> - The EntityBehaviour Type
+     */
+    @Nullable
+    <T extends Entity, B extends de.verdox.mccreativelab.behaviour.entity.EntityBehaviour<T>> B getCustomEntityBehaviour(Class<? extends B> behaviourType);
+    /**
+     * Gets the custom behaviour for this entity if it is available and has the provided type
+     * @param behaviourType - The type of behaviour
+     * @param <T> - The Bukkit Entity Type
+     * @param <B> - The EntityBehaviour Type
+     */
+    <T extends Entity, B extends de.verdox.mccreativelab.behaviour.entity.EntityBehaviour<T>> B getCustomEntityBehaviourIfAvailable(Class<? extends B> behaviourType);
+
+    boolean hasCustomEntityBehaviour();
+    // MCCreativeLab end - Add EntityBehaviour
+
     /**
      * Add a tag to this entity.
      * <br>
diff --git a/src/main/java/org/bukkit/inventory/FoodProperties.java b/src/main/java/org/bukkit/inventory/FoodProperties.java
new file mode 100644
index 0000000000000000000000000000000000000000..88dca90d372244ff9d57263984ad797182fb3e10
--- /dev/null
+++ b/src/main/java/org/bukkit/inventory/FoodProperties.java
@@ -0,0 +1,14 @@
+package org.bukkit.inventory;
+
+import it.unimi.dsi.fastutil.Pair;
+import org.bukkit.potion.PotionEffect;
+
+import java.util.List;
+
+public interface FoodProperties {
+    int getNutrition();
+    float getSaturationModifier();
+    boolean canAlwaysEat();
+    float getEatSeconds();
+    List<Pair<PotionEffect, Float>> getEffects();
+}
diff --git a/src/main/java/org/bukkit/inventory/ItemStack.java b/src/main/java/org/bukkit/inventory/ItemStack.java
index 7669ff31f7896c128a9ce08f3fd941f1b44ee80f..2cba8a66b5ec0a1429e43c21d5204e3deab933b5 100644
--- a/src/main/java/org/bukkit/inventory/ItemStack.java
+++ b/src/main/java/org/bukkit/inventory/ItemStack.java
@@ -122,6 +122,7 @@ public class ItemStack implements Cloneable, ConfigurationSerializable, Translat
         if (data != null) {
             createData(data);
         }
+        de.verdox.itemformat.BasicItemFormat.applyItemFormatAndReturn(this);
     }
 
     /**
@@ -141,6 +142,7 @@ public class ItemStack implements Cloneable, ConfigurationSerializable, Translat
         if (stack.hasItemMeta()) {
             setItemMeta0(stack.getItemMeta(), type);
         }
+        de.verdox.itemformat.BasicItemFormat.applyItemFormatAndReturn(this);
     }
 
     /**
@@ -895,6 +897,30 @@ public class ItemStack implements Cloneable, ConfigurationSerializable, Translat
         return this;
     }
 
+    // MCCLab start - Add ItemBehaviour as instance to this specific Item Stack
+    @Nullable private de.verdox.mccreativelab.behaviour.ItemBehaviour itemBehaviour;
+    public void setItemBehaviour(@Nullable de.verdox.mccreativelab.behaviour.ItemBehaviour itemBehaviour){
+        this.itemBehaviour = itemBehaviour;
+    }
+
+    public boolean hasCustomItemBehaviour(){
+        return this.itemBehaviour != null;
+    }
+
+    public @Nullable de.verdox.mccreativelab.behaviour.ItemBehaviour getDefinedItemBehaviour(){
+        return this.itemBehaviour;
+    }
+
+    public @Nullable de.verdox.mccreativelab.behaviour.ItemBehaviour getItemBehaviour(){
+        if(this.itemBehaviour != null)
+            return this.itemBehaviour;
+        else
+            return de.verdox.mccreativelab.behaviour.ItemBehaviour.ITEM_BEHAVIOUR.getBehaviour(de.verdox.mccreativelab.recipe.CustomItemData.fromItemStack(this));
+    }
+
+
+    // MCCLab end - Add ItemBehaviour as instance to this specific Item Stack
+
     /**
      * If the item has lore, returns it, else it will return null
      * @return The lore, or null
